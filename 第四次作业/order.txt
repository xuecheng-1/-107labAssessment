I.创建一个仓库

$ mkdir name //创建一个名为name的空文件夹
$ cd name //进入name文件夹
$ pwd //显示当前目录
$ git init //把name文件夹变成git可以管理的仓库

   -->Initialized empty Git repository in /Users/michael/name/.get/

II.把文件添加到版本库

编写一个readme.txt文件，内容如下：
Git is a version control system.
Git is free software.
放到name目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git找不到这个文件。

(1).
$ git add readme.txt //首先用git add把文件放到gti仓库
$ git commmit -m "wrote a readme file" //再用git commit把文件提交到仓库

  --> [master (root-commit) eaadf4e] wrote a readme file
		1 file changed, 2 insertions(+) //1 file changed：1个文件被改动（我们新添加的readme.txt文件）；
										//2 insertions：插入了两行内容（readme.txt有两行内容）。
		create mode 100644 readme.txt

  --> -m后面输入的是本次提交的说明，可以输入任意内容
  
(2).commit一次提交很多文件，所以可以多次add不同的文件
$ git add file1.txt //git add . 提交所有文件到暂存区
$ git add file2.txt file3.txt
$ git commit -m "add 3 files."

III.用ls或者dir命令查看当前目录的文件
  
Iv.修改并提交文件

修改readme.txt文件，改成如下内容：
Git is a distributed version control system.
Git is free software.

$ git status //运行git status命令看看结果,该命令可以让我们时刻掌握仓库当前的状态，下面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。
-->On branch master
	Changes not staged for commit:
	(use "git add <file>..." to update what will be committed)
	(use "git checkout -- <file>..." to discard changes in working directory)

		modified:   readme.txt

	no changes added to commit (use "git add" and/or "git commit -a")
	
$ git diff readme.txt //git diff就是查看difference，显示的格式是Unix通用的diff格式，可以从下面的命令输出看到，我们在第一行添加了一个distributed单词。
--> diff --git a/readme.txt b/readme.txt
	index 46d49bf..9247db6 100644
	--- a/readme.txt
	+++ b/readme.txt
	@@ -1,2 +1,2 @@
	-Git is a version control system.
	+Git is a distributed version control system.
	Git is free software.

//提交修改和提交新文件是一样的两步
$ git add readme.txt //正常情况下没有任何提示
$ git commit -m "add distributed"
-->[master e475afc] add distributed
	1 file changed, 1 insertion(+), 1 deletion(-)

//如果多次修改
如果操作过程是：
	第一次修改 -> git add -> 第二次修改 -> git commit 
此时第二次修改没有被提交
要提交第二次修改的话，可以继续git add再git commit，
也可以先不提交第一次修改，
先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：
	第一次修改 -> git add -> 第二次修改 -> git add -> git commit
	
也就是说，每次修改，如果不用git add到暂存区，那就不会加入到commit中。
具体来说：  改一下
			$ git add readme.txt
			再改一下
			$ git add readme.txt
			$ git commit -m "git tracks changes"

V.	
$ git log 查看提交历史记录
$ git log --pretty=oneline //如果嫌输出信息太多，看得眼花缭乱的，可以加上--pretty=oneline参数

VI.版本回退
$ git reset --hard HEAD^ //如果回到前100个版本就是HEAD~100；

如果回退之后想回到未来的那一个版本，只要上面的命令行窗口还没有被关掉，就可以顺着往上找到那个版本的commit id是1094adb...，于是就可以指定回到未来的某个版本：

$ git reset --hard 1094a //版本号没必要写全，前几位就可以了，Git会自动去找。
-->HEAD is now at 83b0afe append GPL

如果上面的命令行窗口关了，可以查看id：
$ git reflog //查看命令地址
e475afc HEAD@{1}: reset: moving to HEAD^
1094adb (HEAD -> master) HEAD@{2}: commit: append GPL
e475afc HEAD@{3}: commit: add distributed
eaadf4e HEAD@{4}: commit (initial): wrote a readme file

VII.撤销修改
（1）.还没有git add
$ git checkout -- readme.txt //命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：

								一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；

								一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。

								总之，就是让这个文件回到最近一次git commit或git add时的状态。
git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令

（2）.已经git add，但还没提交
$ git reset HEAD readme.txt //用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区：
-->Unstaged changes after reset:
		M	readme.txt
然后在进行（1）中操作。		
//git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。

（3）.
已经提交了不合适的修改到版本库时，想要撤销本次提交，版本回退，不过前提是没有推送到远程库.

VIII.删除文件
（1）.确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：

$ git rm test.txt
-->rm 'test.txt'

$ git commit -m "remove test.txt"
-->[master d46f35e] remove test.txt
   1 file changed, 1 deletion(-)
   delete mode 100644 test.txt
   
（2）.删错了，因为版本库里还有，所以可以很轻松地把误删的文件恢复到最新版本：

$ git checkout -- test.txt //git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。

也就是说，命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。


A. 查看全部配置 git config -l
	查看系统配置 git config --system --list
	查看本地配置 git config --global --list
	
B.克隆远程仓库 git clone [url]

C.忽略文件 
在主文件下建立“.gitignore”文件，此文件规则如下
  1. *.txt -->忽略所有.txt结尾的文件
  2. ！lib.txt -->lib.txt除外
  3. /temp -->名称前面有/表示要忽略的是此目录下该名称的子目录，而子目录下的文件不忽略
  4. build/ -->忽略build目录下的所有文件
  5. doc/*.txt -->会忽略doc/note.txt,但不忽略doc/serve/sc.txt
  

  


